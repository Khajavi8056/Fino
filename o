اوکی رفیق. کاملاً متوجه شدم. توضیحات قبلی من زیادی پیچیده بود. عذر می‌خوام. بیا از اول و خیلی ساده و شفاف، دقیقاً طبق چیزی که تو می‌خوای جلو بریم.
نقشه ما اینه:
 * تابع HFiboGetSignal رو نگه می‌داریم، اسمش عوض نمیشه.
 * همین تابع رو آپدیت می‌کنیم تا علاوه بر سیگنال، اطلاعات ناحیه طلایی و نقطه صفر مادر رو هم به ما بده.
 * تصمیم نهایی برای ورود (بعد از چک کردن کراس مووینگ) در HipoFino گرفته میشه.
این راهنمای دقیق و قدم به قدم برای پیاده‌سازی این منطقه.
## قدم اول: ارتقاء کتابخانه HipoFibonacci.mqh
اینجا باید دو بخش رو تغییر بدیم.
الف) تغییر ساختار SSignal
اول باید ساختار SSignal رو آپدیت کنیم تا بتونه اطلاعات جدید رو هم داخل خودش نگه داره.
 * فایل: HipoFibonacci.mqh
 * مکان: حدوداً خط ۱۴۰، بالای تعریف کلاس CFractalFinder.
این کد رو پیدا کن:
struct SSignal
{
   string type;    // "Buy" یا "Sell"
   string id;      // شناسه منحصربه‌فرد
};

و با کد جدید زیر جایگزینش کن:
// ساختار جدید و کامل‌تر SSignal
struct SSignal
{
   string type;                // "Buy" یا "Sell" (فقط وقتی سیگنال هست پر میشه)
   string id;                  // شناسه منحصربه‌فرد (فقط وقتی سیگنال هست پر میشه)
   
   // --- بخش جدید ---
   bool   isStructureActive;   // آیا ساختار فیبوناچی معتبری فعال است؟
   double goldenZoneTop;       // سقف ناحیه طلایی
   double goldenZoneBottom;    // کف ناحیه طلایی
   double motherAnchorPrice;   // قیمت نقطه صفر مادر (نقطه ابطال)
};

ب) بازنویسی کامل متد CFamily::GetSignal
حالا باید متد اصلی که این ساختار رو پر می‌کنه رو بازنویسی کنیم. این متد الان خیلی هوشمندتر میشه.
 * فایل: HipoFibonacci.mqh
 * مکان: داخل کلاس CFamily (حدوداً خط ۱۲۹۰).
کل متد GetSignal فعلی رو پاک کن و کد کامل زیر رو به جاش قرار بده:
//+------------------------------------------------------------------+
//| CFamily::GetSignal (نسخه جدید با ارسال کامل داده‌ها)
//+------------------------------------------------------------------+
SSignal GetSignal()
{
   SSignal signal;
   // مقداردهی اولیه به مقادیر پیش‌فرض
   signal.type = "";
   signal.id = "";
   signal.isStructureActive = false;
   signal.goldenZoneTop = 0;
   signal.goldenZoneBottom = 0;
   signal.motherAnchorPrice = 0;

   // اگر ساختار معتبر نیست، یک سیگنال خالی برگردان
   if(m_state == FAILED || m_state == COMPLETED || m_mother == NULL)
      return signal;

   // اگر ساختار معتبر است، اطلاعات پایه را پر کن
   signal.isStructureActive = true;
   signal.motherAnchorPrice = m_mother.GetPrice0();

   // اگر هنوز به ناحیه طلایی نرسیده‌ایم، فقط اطلاعات پایه را برگردان
   if(m_state != CHILD2_ACTIVE || m_child2 == NULL)
      return signal;
   
   // --- اینجا یعنی به ناحیه طلایی رسیده‌ایم، پس مرزها را محاسبه کن ---
   string temp_levels[];
   if(StringSplit(InpGoldenZone, ',', temp_levels) < 2)
      return signal; // اگر تنظیمات ناحیه طلایی اشتباه بود، ادامه نده
      
   double level_1_percent = StringToDouble(temp_levels[0]) / 100.0;
   double level_2_percent = StringToDouble(temp_levels[1]) / 100.0;
      
   double price0 = m_child2.GetPrice0();
   double price100 = m_child2.GetPrice100();

   double price_level_1 = price100 + (price0 - price100) * level_1_percent;
   double price_level_2 = price100 + (price0 - price100) * level_2_percent;
      
   signal.goldenZoneTop = MathMax(price_level_1, price_level_2);
   signal.goldenZoneBottom = MathMin(price_level_1, price_level_2);
      
   // --- حالا بررسی کن آیا قیمت فعلی داخل ناحیه هست تا سیگنال صادر شود ---
   double current_price = (m_direction == LONG) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   if(current_price <= signal.goldenZoneTop && current_price >= signal.goldenZoneBottom)
   {
      signal.type = (m_direction == LONG) ? "Buy" : "Sell";
      signal.id = m_id + "_" + TimeToString(TimeCurrent());
   }
   
   return signal;
}

## قدم دوم: ارتقاء کتابخانه HipoFino.mqh
حالا باید موتور اصلی رو آپدیت کنیم تا بتونه با گزارش‌های جدید و کامل HipoFibonacci کار کنه.
الف) افزودن تابع کمکی CheckConfirmationCross
این تابع رو برای بررسی کراس مووینگ‌ها به کلاس CHipoFino اضافه می‌کنیم.
 * فایل: HipoFino.mqh
 * مکان: داخل کلاس CHipoFino، در بخش private (مثلاً حدوداً خط ۳۵۰).
این کد کامل رو در اونجا قرار بده:
private:
   // ... (سایر متغیرهای خصوصی)

   // --- تابع جدید برای تایید کراس ---
   bool CheckConfirmationCross(ENUM_DIRECTION direction, int fast_period, int slow_period)
   {
      double fast_ma[2];
      double slow_ma[2];

      int fast_ma_handle = iMA(_Symbol, PERIOD_CURRENT, fast_period, 0, MODE_EMA, PRICE_CLOSE);
      int slow_ma_handle = iMA(_Symbol, PERIOD_CURRENT, slow_period, 0, MODE_EMA, PRICE_CLOSE);

      if(CopyBuffer(fast_ma_handle, 0, 1, 2, fast_ma) < 2) return false;
      if(CopyBuffer(slow_ma_handle, 0, 1, 2, slow_ma) < 2) return false;
      
      // ایندکس 0 => کندل شیفت 1 (کندل قبلی)
      // ایندکس 1 => کندل شیفت 2 (دو کندل قبل)
      
      if(direction == LONG)
      {
         if(fast_ma[1] < slow_ma[1] && fast_ma[0] > slow_ma[0])
            return true;
      }
      else // SHORT
      {
         if(fast_ma[1] > slow_ma[1] && fast_ma[0] < slow_ma[0])
            return true;
      }
      
      return false;
   }

ب) بازنویسی منطق تصمیم‌گیری در OnTick
این آخرین و مهم‌ترین مرحله است. باید بخش HIPO_WAITING_FOR_HIPO رو با منطق جدید جایگزین کنیم.
 * فایل: HipoFino.mqh
 * مکان: داخل تابع OnTick، case HIPO_WAITING_FOR_HIPO: (حدوداً خط ۶۰۰).
کل case HIPO_WAITING_FOR_HIPO: فعلی رو پاک کن و کد کامل زیر رو به جاش قرار بده:
case HIPO_WAITING_FOR_HIPO:
{
   // شرایط اضطراری مثل قبل باقی می‌مانند
   if((m_active_direction == LONG && htf_bias == MACD_BEARISH) ||
      (m_active_direction == SHORT && htf_bias == MACD_BULLISH))
   {
      HFiboStopCurrentStructure();
      m_state = HIPO_IDLE;
      Log("روند HTF معکوس شد، ساختار متوقف شد");
      break;
   }

   // --- منطق جدید و هوشمند ---
   SSignal signal = HFiboGetSignal();

   // ۱. آیا اصلاً ساختار فعالی وجود دارد؟
   if(!signal.isStructureActive)
   {
      // اگر ساختار به هر دلیلی (مثل فیل شدن) از بین رفته بود
      if(HFiboIsStructureBroken())
      {
         HFiboStopCurrentStructure();
         m_state = HIPO_IDLE;
         Log("ساختار فیبوناچی تخریب شد، بازگشت به حالت بیکار");
      }
      break;
   }

   // ۲. فیلتر ایمنی: آیا قیمت از نقطه ابطال عبور کرده؟
   double current_price_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double current_price_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if((m_active_direction == LONG && current_price_bid < signal.motherAnchorPrice) ||
      (m_active_direction == SHORT && current_price_ask > signal.motherAnchorPrice))
   {
      Log("نقطه ابطال ساختار (لنگرگاه مادر) زده شد. ساختار فیل شد.");
      HFiboStopCurrentStructure();
      m_state = HIPO_IDLE;
      break;
   }
   
   // ۳. آیا سیگنال ورود (قرار گرفتن در ناحیه طلایی) صادر شده؟
   if(signal.id != "")
   {
      // ۴. اگر بله، حالا فیلتر کراس مووینگ را بررسی کن
      if(CheckConfirmationCross(m_active_direction, 5, 8))
      {
         double entry_price = (signal.type == "Buy") ? current_price_ask : current_price_bid;
         double sl_price = (signal.type == "Buy") ? signal.motherAnchorPrice - m_sl_buffer_pips * _Point :
                                                     signal.motherAnchorPrice + m_sl_buffer_pips * _Point;

         if(SendTrade(signal, entry_price, sl_price))
         {
            m_state = HIPO_MANAGING_POSITION;
            Log("وارد حالت مدیریت معامله شد (با تایید کراس)");
         }
         else
         {
            HFiboStopCurrentStructure();
            m_state = HIPO_IDLE;
         }
      }
   }
   break;
}

با انجام این تغییرات، سیستمت دقیقاً همونطور که می‌خواستی کار می‌کنه. HipoFibonacci اطلاعات کامل رو میده و HipoFino با اون اطلاعات و فیلتر خودش، تصمیم نهایی رو می‌گیره.
