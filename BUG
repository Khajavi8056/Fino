//+------------------------------------------------------------------+
//|                                                      Memento.mq5 |
//|                                  Copyright 2025, Mohammad & Gemini |
//|                                           Version 8.0 - Custom Logic |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mohammad & Gemini"
#property link      ""
#property version   "8.0" // پیاده‌سازی منطق تلاقی سفارشی
#property description "اکسپرت ممنتو بر اساس تلاقی چیکو اسپن حال با سطوح گذشته"

#include <Trade\Trade.mqh>
#include <Object.mqh>

//--- تنظیمات عمومی
input group "General Settings"
input string Inp_Symbols_List = "EURUSD,GBPUSD,XAUUSD"; // لیست نمادها به صورت جدا شده با کاما
input int    Inp_Magic_Number = 12345;                 // شماره جادویی برای معاملات
input bool   Inp_Enable_Logging = true;                // فعال‌سازی لاگ‌های دقیق

//--- تنظیمات ایچیموکو
input group "Ichimoku Settings"
input int Inp_Tenkan_Period = 9;           // دوره تنکان-سن
input int Inp_Kijun_Period = 26;           // دوره کیجون-سن
input int Inp_Senkou_Span_B_Period = 52;   // دوره سنکو اسپن بی

//--- پارامترهای سیگنال و تأیید
input group "Signal & Confirmation Settings"
enum E_Confirmation_Mode { MODE_CLOSE_ONLY, MODE_OPEN_AND_CLOSE };
input E_Confirmation_Mode Inp_Confirmation_Type = MODE_OPEN_AND_CLOSE; // نوع تأیید قیمت
input int Inp_Grace_Period_Candles = 5;    // دوره مهلت تأیید

//--- تنظیمات استاپ لاس
input group "Stop Loss Settings"
enum E_SL_Mode { MODE_COMPLEX, MODE_SIMPLE };
input E_SL_Mode Inp_StopLoss_Type = MODE_COMPLEX; // روش محاسبه استاپ لاس
input int Inp_SL_Lookback_Period = 15;     // دوره نگاه به عقب برای استاپ لاس
input double Inp_SL_Buffer_Multiplier = 3.0; // ضریب بافر استاپ لاس (بر اساس نقطه نماد)

//--- مدیریت مالی و معاملات
input group "Money & Trade Management"
input double Inp_Risk_Percent_Per_Trade = 1.0; // درصد ریسک در هر معامله
input double Inp_Take_Profit_Ratio = 1.5; // نسبت ریسک به پاداش برای حد سود
input int    Inp_Max_Trades_Per_Symbol = 1;  // حداکثر معاملات باز برای هر نماد
input int    Inp_Max_Total_Trades = 5;       // حداکثر کل معاملات باز

//--- تنظیمات تحمل
input group "Tolerance Settings"
input double Inp_Talaqi_Tolerance_Multiplier = 3.0; // ضریب تحمل تلاقی (بر اساس نقطه نماد)

//--- تنظیمات گرافیکی
input group "Graphical Settings"
input double Inp_Object_Distance_Multiplier = 10.0; // ضریب فاصله اشیاء گرافیکی
input bool   Inp_Show_Ichimoku_Lines = true; // نمایش خطوط ایچیموکو در حالت ویژوال
input color  Inp_Tenkan_Color = clrRed;       // رنگ تنکان-سن
input color  Inp_Kijun_Color = clrDodgerBlue; // رنگ کیجون-سن
input color  Inp_Chikou_Color = clrWhite;     // رنگ چیکو اسپن

class CSettings {
public:
    string symbols_list;
    int tenkan_period, kijun_period, senkou_span_b_period;
    E_Confirmation_Mode confirmation_type;
    int grace_period_candles;
    E_SL_Mode stoploss_type;
    int sl_lookback_period;
    double sl_buffer_multiplier;
    double risk_percent_per_trade;
    double take_profit_ratio;
    double talaqi_tolerance_multiplier;
    int magic_number;
    bool enable_logging;
    double object_distance_multiplier;
    int max_trades_per_symbol;
    int max_total_trades;
    bool show_ichimoku_lines;
    color tenkan_color;
    color kijun_color;
    color chikou_color;

    void Init() {
        symbols_list = Inp_Symbols_List;
        tenkan_period = Inp_Tenkan_Period;
        kijun_period = Inp_Kijun_Period;
        senkou_span_b_period = Inp_Senkou_Span_B_Period;
        confirmation_type = Inp_Confirmation_Type;
        grace_period_candles = Inp_Grace_Period_Candles;
        stoploss_type = Inp_StopLoss_Type;
        sl_lookback_period = Inp_SL_Lookback_Period;
        sl_buffer_multiplier = Inp_SL_Buffer_Multiplier;
        risk_percent_per_trade = Inp_Risk_Percent_Per_Trade;
        take_profit_ratio = Inp_Take_Profit_Ratio;
        talaqi_tolerance_multiplier = Inp_Talaqi_Tolerance_Multiplier;
        magic_number = Inp_Magic_Number;
        enable_logging = Inp_Enable_Logging;
        object_distance_multiplier = Inp_Object_Distance_Multiplier;
        max_trades_per_symbol = Inp_Max_Trades_Per_Symbol;
        max_total_trades = Inp_Max_Total_Trades;
        show_ichimoku_lines = Inp_Show_Ichimoku_Lines;
        tenkan_color = Inp_Tenkan_Color;
        kijun_color = Inp_Kijun_Color;
        chikou_color = Inp_Chikou_Color;
    }
};

class CSymbolManager {
private:
    bool is_valid;
    string symbol;
    int ichimoku_handle;
    int chart_indicator_handle;
    datetime last_bar_time;
    CTrade trade;

    struct PotentialSignal {
        datetime time;
        bool is_buy;
        int age;
    };
    PotentialSignal potential_signals[];

    void Log(string message) {
        if (settings.enable_logging) {
            Print(symbol + ": " + message);
        }
    }

    void AddPotentialSignal(bool is_buy) {
        PotentialSignal signal;
        signal.time = iTime(symbol, PERIOD_CURRENT, 0);
        signal.is_buy = is_buy;
        signal.age = 0;
        int size = ArraySize(potential_signals);
        ArrayResize(potential_signals, size + 1);
        potential_signals[size] = signal;
        Log("سیگنال بالقوه " + (is_buy ? "خرید" : "فروش") + " در " + TimeToString(signal.time) + " اضافه شد.");
    }

public:
    bool IsValid() { return is_valid; }

    void Init(string sym) {
        is_valid = false;
        symbol = sym;
        ichimoku_handle = iIchimoku(symbol, PERIOD_CURRENT, settings.tenkan_period, settings.kijun_period, settings.senkou_span_b_period);
        if (ichimoku_handle == INVALID_HANDLE) {
            Log("خطا در ایجاد اندیکاتور Ichimoku.");
            return;
        }
        last_bar_time = 0;
        ArrayFree(potential_signals);
        trade.SetExpertMagicNumber(settings.magic_number);
        
        chart_indicator_handle = -1;
        if (settings.show_ichimoku_lines && MQLInfoInteger(MQL_VISUAL_MODE)) {
            chart_indicator_handle = iIchimoku(symbol, PERIOD_CURRENT, settings.tenkan_period, settings.kijun_period, settings.senkou_span_b_period);
            if(chart_indicator_handle != INVALID_HANDLE) {
                IndicatorSetInteger(chart_indicator_handle, INDICATOR_LINE_COLOR, 0, settings.tenkan_color);
                IndicatorSetInteger(chart_indicator_handle, INDICATOR_LINE_COLOR, 1, settings.kijun_color);
                IndicatorSetInteger(chart_indicator_handle, INDICATOR_LINE_COLOR, 2, clrNONE);
                IndicatorSetInteger(chart_indicator_handle, INDICATOR_LINE_COLOR, 3, clrNONE);
                IndicatorSetInteger(chart_indicator_handle, INDICATOR_LINE_COLOR, 4, settings.chikou_color);
                ChartIndicatorAdd(0, 0, chart_indicator_handle);
            }
        }
        is_valid = true;
        Log("نماد با موفقیت مقداردهی اولیه شد.");
    }

    void ProcessNewBar() {
        datetime current_bar_time = iTime(symbol, PERIOD_CURRENT, 0);
        if (current_bar_time != last_bar_time) {
            last_bar_time = current_bar_time;
            CheckConfluence();
            CheckConfirmations();
        }
    }

    // +++ START OF MODIFIED LOGIC +++
    // این تابع با منطق سفارشی ما بازنویسی شده است
    void CheckConfluence() {
        // 1. تعیین محل وقوع رویداد در گذشته
        int history_shift = settings.kijun_period; // معمولاً 26

        // 2. تعیین کندل شاهد ماجرا در زمان حال
        int current_shift = 1;

        // مطمئن میشیم دیتای کافی داریم
        if (iBars(symbol, PERIOD_CURRENT) < history_shift + 2) return;

        // 3. مقدار شاهد ماجرا (چیکواسپن) رو از کندل شماره ۱ می‌خونیم
        double chikou_value = iClose(symbol, PERIOD_CURRENT, current_shift);

        // 4. مقادیر دو خط اصلی (تنکان و کیجون) رو از 26 کندل قبل می‌خونیم
        double tenkan_history[], kijun_history[];
        ArraySetAsSeries(tenkan_history, true);
        ArraySetAsSeries(kijun_history, true);
        if (CopyBuffer(ichimoku_handle, 0, history_shift, 1, tenkan_history) <= 0 || CopyBuffer(ichimoku_handle, 1, history_shift, 1, kijun_history) <= 0) {
            Log("خطا در گرفتن مقادیر تنکان/کیجون از گذشته.");
            return;
        }

        // 5. بررسی تلاقی بین شاهد امروزی و خطوط قدیمی
        double tolerance = settings.talaqi_tolerance_multiplier * SymbolInfoDouble(symbol, SYMBOL_POINT);
        double max_val = MathMax(chikou_value, MathMax(tenkan_history[0], kijun_history[0]));
        double min_val = MathMin(chikou_value, MathMin(tenkan_history[0], kijun_history[0]));

        if (max_val - min_val < tolerance) {
            // تلاقی پیدا شد! حالا جهت رو مشخص می‌کنیم
            Log("تلاقی بین چیکو اسپن فعلی و سطوح گذشته پیدا شد در شیفت: " + IntegerToString(history_shift));
            DrawConfluenceObject(history_shift); // علامت تلاقی رو در محل رویداد تاریخی میذاریم

            // اگر در گذشته، تنکان بالای کیجون بوده (روند صعودی) و قیمت الان هم بالای اون سطوح هست -> سیگنال خرید
            if (tenkan_history[0] > kijun_history[0] && chikou_value > tenkan_history[0]) {
                AddPotentialSignal(true);
                DrawFlagObject(history_shift, true);
            }
            // اگر در گذشته، کیجون بالای تنکان بوده (روند نزولی) و قیمت الان هم پایین اون سطوح هست -> سیگنال فروش
            else if (kijun_history[0] > tenkan_history[0] && chikou_value < kijun_history[0]) {
                AddPotentialSignal(false);
                DrawFlagObject(history_shift, false);
            }
        }
    }
    // +++ END OF MODIFIED LOGIC +++

    void CheckConfirmations() {
        for (int i = ArraySize(potential_signals) - 1; i >= 0; i--) {
            if (potential_signals[i].age > settings.grace_period_candles) {
                Log("سیگنال " + (potential_signals[i].is_buy ? "خرید" : "فروش") + " منقضی شد.");
                ArrayRemove(potential_signals, i, 1);
                continue;
            }
            if (CheckConfirmation(potential_signals[i].is_buy)) {
                Log("سیگنال " + (potential_signals[i].is_buy ? "خرید" : "فروش") + " تأیید شد.");
                DrawConfirmationObject(1, potential_signals[i].is_buy);
                OpenTrade(potential_signals[i].is_buy);
                ArrayRemove(potential_signals, i, 1);
            } else {
                potential_signals[i].age++;
            }
        }
    }

    bool CheckConfirmation(bool is_buy) {
        double tenkan[], kijun[];
        ArraySetAsSeries(tenkan, true);
        ArraySetAsSeries(kijun, true);
        if (CopyBuffer(ichimoku_handle, 0, 1, 1, tenkan) <= 0 || CopyBuffer(ichimoku_handle, 1, 1, 1, kijun) <= 0) {
            Log("خطا در کپی کردن بافرهای تأیید.");
            return false;
        }
        double close1 = iClose(symbol, PERIOD_CURRENT, 1);
        double open1 = iOpen(symbol, PERIOD_CURRENT, 1);

        if (is_buy) {
            if (kijun[0] >= tenkan[0]) return false;
            if (settings.confirmation_type == MODE_CLOSE_ONLY) {
                if (close1 <= tenkan[0] || close1 <= kijun[0]) return false;
            } else {
                if (open1 <= tenkan[0] || open1 <= kijun[0] || close1 <= tenkan[0] || close1 <= kijun[0]) return false;
            }
        } else {
            if (kijun[0] <= tenkan[0]) return false;
            if (settings.confirmation_type == MODE_CLOSE_ONLY) {
                if (close1 >= tenkan[0] || close1 >= kijun[0]) return false;
            } else {
                if (open1 >= tenkan[0] || open1 >= kijun[0] || close1 >= tenkan[0] || close1 >= kijun[0]) return false;
            }
        }
        return true;
    }

    void OpenTrade(bool is_buy) {
        if (CountTotalTrades() >= settings.max_total_trades || CountSymbolTrades() >= settings.max_trades_per_symbol) {
            Log("رسیدن به حد مجاز معاملات. معامله جدید باز نشد.");
            return;
        }
        double sl = CalculateSL(is_buy);
        if (sl == 0) {
            Log("نمی‌توان استاپ لاس را محاسبه کرد. معامله باز نشد.");
            return;
        }
        double entry_price = is_buy ? SymbolInfoDouble(symbol, SYMBOL_ASK) : SymbolInfoDouble(symbol, SYMBOL_BID);
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double tick_value = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
        if (tick_value <= 0) {
            Log("مقدار Tick Value نامعتبر است.");
            return;
        }
        double sl_distance_points = MathAbs(entry_price - sl) / point;
        if (sl_distance_points < 1) {
            Log("فاصله استاپ لاس بسیار کم است.");
            return;
        }
        double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * (settings.risk_percent_per_trade / 100.0);
        double lot_size = risk_amount / (sl_distance_points * tick_value);
        double min_lot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
        double max_lot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
        double lot_step = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
        lot_size = MathMax(min_lot, MathMin(max_lot, MathRound(lot_size / lot_step) * lot_step));
        lot_size = NormalizeDouble(lot_size, 2);
        double tp_distance_points = sl_distance_points * settings.take_profit_ratio;
        double tp = is_buy ? entry_price + tp_distance_points * point : entry_price - tp_distance_points * point;
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        sl = NormalizeDouble(sl, digits);
        tp = NormalizeDouble(tp, digits);
        string comment = is_buy ? "Memento Buy" : "Memento Sell";
        if (is_buy) {
            if (!trade.Buy(lot_size, symbol, 0, sl, tp, comment)) Log("خطا در باز کردن معامله خرید: " + IntegerToString(GetLastError()));
            else Log("معامله خرید با لات " + DoubleToString(lot_size, 2) + " باز شد.");
        } else {
            if (!trade.Sell(lot_size, symbol, 0, sl, tp, comment)) Log("خطا در باز کردن معامله فروش: " + IntegerToString(GetLastError()));
            else Log("معامله فروش با لات " + DoubleToString(lot_size, 2) + " باز شد.");
        }
    }

    double CalculateSL(bool is_buy) {
        double buffer = settings.sl_buffer_multiplier * SymbolInfoDouble(symbol, SYMBOL_POINT);
        if (settings.stoploss_type == MODE_COMPLEX) {
            double flat_kijun = FindFlatKijun();
            if (flat_kijun != 0) return is_buy ? flat_kijun - buffer : flat_kijun + buffer;
            double pivot_kijun = FindPivotKijun(is_buy);
            if (pivot_kijun != 0) return is_buy ? pivot_kijun - buffer : pivot_kijun + buffer;
            double pivot_tenkan = FindPivotTenkan(is_buy);
            if (pivot_tenkan != 0) return is_buy ? pivot_tenkan - buffer : pivot_tenkan + buffer;
        }
        return FindDefaultSL(is_buy, buffer);
    }
    
    double FindDefaultSL(bool is_buy, double buffer){
       double default_sl = 0;
       for (int i = 1; i <= settings.sl_lookback_period; i++) {
            double open = iOpen(symbol, PERIOD_CURRENT, i);
            double close = iClose(symbol, PERIOD_CURRENT, i);
            if (is_buy && close < open){
               default_sl = iLow(symbol, PERIOD_CURRENT, i);
               break;
            }
            if (!is_buy && close > open){
                default_sl = iHigh(symbol, PERIOD_CURRENT, i);
                break;
            }
        }
        if(default_sl == 0) return 0;
        return is_buy ? default_sl - buffer : default_sl + buffer;
    }

    double FindFlatKijun() {
        double kijun[];
        int copy_count = settings.sl_lookback_period + 2;
        if (CopyBuffer(ichimoku_handle, 1, 0, copy_count, kijun) < copy_count) return 0;
        ArraySetAsSeries(kijun, true);
        for (int i = 0; i < copy_count - 2; i++) {
            if (kijun[i] == kijun[i+1] && kijun[i+1] == kijun[i+2]) return kijun[i];
        }
        return 0;
    }

    double FindPivotKijun(bool is_buy) {
        double kijun[];
        int copy_count = settings.sl_lookback_period + 1;
        if (CopyBuffer(ichimoku_handle, 1, 0, copy_count, kijun) < copy_count) return 0;
        ArraySetAsSeries(kijun, true);
        for (int i = 1; i < copy_count - 1; i++) {
            if (is_buy && kijun[i] < kijun[i-1] && kijun[i] < kijun[i+1]) return kijun[i];
            if (!is_buy && kijun[i] > kijun[i-1] && kijun[i] > kijun[i+1]) return kijun[i];
        }
        return 0;
    }

    double FindPivotTenkan(bool is_buy) {
        double tenkan[];
        int copy_count = settings.sl_lookback_period + 1;
        if (CopyBuffer(ichimoku_handle, 0, 0, copy_count, tenkan) < copy_count) return 0;
        ArraySetAsSeries(tenkan, true);
        for (int i = 1; i < copy_count - 1; i++) {
            if (is_buy && tenkan[i] < tenkan[i-1] && tenkan[i] < tenkan[i+1]) return tenkan[i];
            if (!is_buy && tenkan[i] > tenkan[i-1] && tenkan[i] > tenkan[i+1]) return tenkan[i];
        }
        return 0;
    }
    
    int CountSymbolTrades(){
       int count = 0;
       for(int i=PositionsTotal()-1; i>=0; i--){
          if(PositionGetSymbol(i) == symbol && PositionGetInteger(POSITION_MAGIC) == (ulong)settings.magic_number){
             count++;
          }
       }
       return count;
    }
    
    int CountTotalTrades(){
       int count = 0;
       for(int i=PositionsTotal()-1; i>=0; i--){
          if(PositionGetInteger(POSITION_MAGIC) == (ulong)settings.magic_number){
             count++;
          }
       }
       return count;
    }

    void DrawConfluenceObject(int shift) {
        string obj_name = "Confluence_" + symbol + "_" + TimeToString(iTime(symbol, PERIOD_CURRENT, shift));
        double distance = settings.object_distance_multiplier * SymbolInfoDouble(symbol, SYMBOL_POINT);
        ObjectCreate(0, obj_name, OBJ_TEXT, 0, iTime(symbol, PERIOD_CURRENT, shift), iLow(symbol, PERIOD_CURRENT, shift) - distance);
        ObjectSetInteger(0, obj_name, OBJPROP_COLOR, clrDodgerBlue);
        ObjectSetString(0, obj_name, OBJPROP_TEXT, CharToString(71));
        ObjectSetInteger(0, obj_name, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, obj_name, OBJPROP_SELECTABLE, false);
    }

    void DrawFlagObject(int shift, bool is_buy) {
        string obj_name = "Flag_" + symbol + "_" + TimeToString(iTime(symbol, PERIOD_CURRENT, shift));
        double distance = settings.object_distance_multiplier * SymbolInfoDouble(symbol, SYMBOL_POINT);
        ObjectCreate(0, obj_name, OBJ_TEXT, 0, iTime(symbol, PERIOD_CURRENT, shift), iHigh(symbol, PERIOD_CURRENT, shift) + distance);
        ObjectSetInteger(0, obj_name, OBJPROP_COLOR, is_buy ? clrGreen : clrRed);
        ObjectSetString(0, obj_name, OBJPROP_TEXT, CharToString(80));
        ObjectSetInteger(0, obj_name, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, obj_name, OBJPROP_SELECTABLE, false);
    }

    void DrawConfirmationObject(int shift, bool is_buy) {
        string obj_name = "Confirm_" + symbol + "_" + TimeToString(iTime(symbol, PERIOD_CURRENT, shift));
        double distance = settings.object_distance_multiplier * SymbolInfoDouble(symbol, SYMBOL_POINT);
        ObjectCreate(0, obj_name, OBJ_TEXT, 0, iTime(symbol, PERIOD_CURRENT, shift), iLow(symbol, PERIOD_CURRENT, shift) - distance);
        ObjectSetInteger(0, obj_name, OBJPROP_COLOR, is_buy ? clrGreen : clrRed);
        ObjectSetString(0, obj_name, OBJPROP_TEXT, CharToString(169));
        ObjectSetInteger(0, obj_name, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, obj_name, OBJPROP_SELECTABLE, false);
    }
};

CSettings settings;
CSymbolManager symbolManagers[];
string symbols[];

int OnInit() {
    settings.Init();
    StringSplit(settings.symbols_list, ',', symbols);
    ArrayResize(symbolManagers, ArraySize(symbols));
    for (int i = 0; i < ArraySize(symbols); i++) {
        string sym = symbols[i];
        StringTrimLeft(sym);
        StringTrimRight(sym);
        symbolManagers[i].Init(sym);
    }
    EventSetTimer(5);
    return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason) {
    EventKillTimer();
    ObjectsDeleteAll(0, "Confluence_");
    ObjectsDeleteAll(0, "Flag_");
    ObjectsDeleteAll(0, "Confirm_");
    
    if(MQLInfoInteger(MQL_VISUAL_MODE)) {
       ChartRedraw(0);
    }
}

void OnTimer() {
    for (int i = 0; i < ArraySize(symbolManagers); i++) {
        if (symbolManagers[i].IsValid()) {
            symbolManagers[i].ProcessNewBar();
        }
    }
}
